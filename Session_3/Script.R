## 1. prepare prerequisites for the analysis ####
### 1-0. installing the required R packages ####
install.packages("iCAMP")
install.packages("reshape2")
install.packages("dplyr")
install.packages("ape")
install.packages("ggplot2")

### 1-1. load R packages #####
library(phyloseq)
library(reshape2)
library(iCAMP)
library(ape)
library(ggplot2)
library(dplyr)

### 1-2. prepare data ####
load(file="./Part2/phyloseq_object.RData")
phyloseq_object

#### 1-2-1. abundance table ####
comm <-t(data.frame(otu_table(phyloseq_object)))
#### 1-2-2. taxonomic information table ####
clas <-data.frame(tax_table(phyloseq_object))
#### 1-2-3. sample metadata ####
metatable <-data.frame(sample_data(phyloseq_object))
treat <- metatable[c(2)] ### Categorical variables
#env <- metatable[c(1,3,4,...)] ### Continuous variables; not available in this workshop.
#### 1-2-4. phylogenetic tree ####
tree <- phyloseq::phy_tree(phyloseq_object)

### (Optional) load data from saved tables #### 
### The code described below can be used when the above tables are saved in a certain folder.
load.wd <- "~/Desktop/SNU/Conference & Seminar/KSPP/2024/PhytobiomeWorkshop/Part3/Input"
setwd(load.wd)
comm <- t(read.table("asv_abundance_table.txt", header = TRUE, sep = "\t", row.names = 1,
                  as.is = TRUE, stringsAsFactors = FALSE, comment.char = "",
                  check.names = FALSE))

clas <- read.table("asv_tax_table.txt", header = TRUE, sep = "\t", row.names = 1,
                as.is = TRUE, stringsAsFactors = FALSE, comment.char = "",
                check.names = FALSE)
treat <- read.table("treat_table.txt", header = TRUE, sep = "\t", row.names = 1,
                 as.is = TRUE, stringsAsFactors = FALSE, comment.char = "",
                 check.names = FALSE)
env <- read.table("enviroment_table.txt", header = TRUE, sep = "\t", row.names = 1,
                    as.is = TRUE, stringsAsFactors = FALSE, comment.char = "",
                    check.names = FALSE)

### 1-3. key parameter setting #####
prefix="Test"  # prefix of the output file names. usually use a project ID.
rand.time=100  # randomization time, 1000 is usually enough. For example test, you may set as 100 or less to save time.
nworker=5 # nworker is thread number for parallel computing, which depends on the CPU core number of your computer.
memory.G=50 # to set the memory size as you need (but should be less than the available space in your hard disk), 
#             so that calculation of large tree will not be limited by physical memory. unit is Gb.

## 2. check data prior to the analysis ####
### 2-1. match sample IDs in the ASV abundance table and treatment information table ####
sampid.check=match.name(rn.list=list(comm=comm,treat=treat,env=env)) # When an env file exists
sampid.check=match.name(rn.list=list(comm=comm,treat=treat)) # if you do not have an env file
### the output should be "All match very well".
### for your data files, if you have not matched their IDs, the unmatched samples will be removed.
treat=sampid.check$treat
comm=sampid.check$comm
comm=comm[,colSums(comm)>0,drop=FALSE] # if some unmatched samples were removed, some ASVs may become ghosts, then you may use this line to remove them if necessary.
env=sampid.check$env # skip this if you do not have an env file

### 2-2. match ASV IDs in ASV table and tree file ####
spid.check=match.name(cn.list=list(comm=comm),rn.list=list(clas=clas),tree.list=list(tree=tree))
# The output should be "All match very well".
# If you have not matched the IDs before, the unmatched ASVs will be removed.
comm=spid.check$comm
clas=spid.check$clas
tree=spid.check$tree

## 3. get pairwise phylogenetic distance matrix ####
### 3-1. set the directory where results will be saved ####
save.wd <- "~/Desktop/SNU/Conference & Seminar/KSPP/2024/PhytobiomeWorkshop/Part3/Output"
setwd(save.wd)

### 3-2. calculate pairwise phylogenetic distance ####
if(!file.exists("pd.desc")) 
{
  pd.big=iCAMP::pdist.big(tree = tree, wd=save.wd, nworker = nworker, memory.G = memory.G)
  # output files:
  # path.rda: a R object to list all the nodes and  edge lengths from root to every tip. saved in R data format. an intermediate output when claculating phylogenetic distance matrix.
  # pd.bin: BIN file (backingfile) generated by function big.matrix in R package bigmemory. 
  #.        This is the big matrix storing pairwise phylogenetic distance values. 
  #         By using this bigmemory format file, we will not need memory but hard disk when calling big matrix for calculation.
  # pd.desc: the DESC file (descriptor file) to hold the backing file (pd.bin) description.
  # pd.taxon.name.csv: comma delimited csv file storing the IDs of tree tips (ASVs), serving as the row/column names of the big phylogenetic distance matrix.
}else{
  # if you already calculated the phylogenetic distance matrix in a previous run
  pd.big=list()
  pd.big$tip.label=read.csv(paste0(save.wd,"/pd.taxon.name.csv"),row.names = 1,stringsAsFactors = FALSE)[,1]
  pd.big$pd.wd=save.wd
  pd.big$pd.file="pd.desc"
  pd.big$pd.name.file="pd.taxon.name.csv"
}

## 4. iCAMP analysis ####
### 4-1. The analysis if an env file is available ####
#### 4-1-1. assess niche preference difference between ASVs #### 
#### env is required for this step.
setwd(save.wd)
niche.dif=iCAMP::dniche(env = env,comm = comm,method = "niche.value",
                        nworker = nworker,out.dist=FALSE,bigmemo=TRUE,
                        nd.wd=save.wd)

#### 4-1-2. within-bin phylogenetic signal assessment ####
#### you may try several different settings of binning, and choose the one leading to the best within-bin phylogenetic signal.
#### env is required for this step.
##### 4-1-2-1. try phylogenetic binning using current setttings ####
ds = 0.2 # setting can be changed to explore the best choice
bin.size.limit = 5 # setting can be changed to explore the best choice. # here set as 5 just for the small example dataset. For real data, usually try 12 to 48.
phylobin=taxa.binphy.big(tree = tree, pd.desc = pd.big$pd.file,pd.spname = pd.big$tip.label,
                         pd.wd = pd.big$pd.wd, ds = ds, bin.size.limit = bin.size.limit,
                         nworker = nworker)
##### 4-1-2-2. test within-bin phylogenetic signal ####
sp.bin=phylobin$sp.bin[,3,drop=FALSE]
sp.ra=colMeans(comm/rowSums(comm))
abcut=3 # you may remove some species, if they are too rare to perform reliable correlation test.
commc=comm[,colSums(comm)>=abcut,drop=FALSE]
dim(commc)
spname.use=colnames(commc)
binps=iCAMP::ps.bin(sp.bin = sp.bin,sp.ra = sp.ra,spname.use = spname.use,
                    pd.desc = pd.big$pd.file, pd.spname = pd.big$tip.label, pd.wd = pd.big$pd.wd,
                    nd.list = niche.dif$nd,nd.spname = niche.dif$names,ndbig.wd = niche.dif$nd.wd,
                    cor.method = "pearson",r.cut = 0.1, p.cut = 0.05, min.spn = 5)
if(file.exists(paste0(prefix,".PhyloSignalSummary.csv"))){appendy=TRUE;col.namesy=FALSE}else{appendy=FALSE;col.namesy=TRUE}
write.table(data.frame(ds=ds,n.min=bin.size.limit,binps$Index),file = paste0(prefix,".PhyloSignalSummary.csv"),
            append = appendy, quote=FALSE, sep=",", row.names = FALSE,col.names = col.namesy)
if(file.exists(paste0(prefix,".PhyloSignalDetail.csv"))){appendy2=TRUE;col.namesy2=FALSE}else{appendy2=FALSE;col.namesy2=TRUE}
write.table(data.frame(ds=ds,n.min=bin.size.limit,binID=rownames(binps$detail),binps$detail),file = paste0(prefix,".PhyloSignalDetail.csv"),
            append = appendy2, quote = FALSE, sep = ",", row.names = FALSE, col.names = col.namesy2)
# usually, you are looking for a binning setting lead to 
# higher RAsig.abj (relative abundance of bins with significant phylogenetic signal) 
# and relative high meanR (mean correlation coefficient across bins).
# see help document of the function "ps.bin" for the meaning of output.

#### 4-1-3. iCAMP analysis ####
bin.size.limit = 5 # use a proper number according to phylogenetic signal test
sig.index="Confidence" ### commonly use # set sig.index as Confidence instead of SES.RC (betaNRI/NTI + RCbray)
# see other options in help document of icamp.big.
icres=iCAMP::icamp.big(comm=comm, pd.desc = pd.big$pd.file, pd.spname=pd.big$tip.label,
                       pd.wd = pd.big$pd.wd, rand = rand.time, tree=tree,
                       prefix = prefix, ds = 0.2, pd.cut = NA, sp.check = TRUE,
                       phylo.rand.scale = "within.bin", taxa.rand.scale = "across.all",
                       phylo.metric = "bMPD", sig.index=sig.index, bin.size.limit = bin.size.limit, 
                       nworker = nworker, memory.G = memory.G, rtree.save = FALSE, detail.save = TRUE, 
                       qp.save = FALSE, detail.null = FALSE, ignore.zero = TRUE, output.wd = save.wd, 
                       correct.special = TRUE, unit.sum = rowSums(comm), special.method = "depend",
                       ses.cut = 1.96, rc.cut = 0.95, conf.cut=0.975, omit.option = "no",meta.ab = NULL)

### 4-2. The analysis if an env file is not available ####
bin.size.limit = 5 # According to the authors, optimum value is 12, 24 (default), or 48.
sig.index="Confidence" ## # commonly use # set sig.index as Confidence instead of SES.RC (betaNRI/NTI + RCbray)
# see other options in help document of icamp.big.
icres=iCAMP::icamp.big(comm=comm, pd.desc = pd.big$pd.file, pd.spname=pd.big$tip.label,
                       pd.wd = pd.big$pd.wd, rand = rand.time, tree=tree,
                       prefix = prefix, ds = 0.2, pd.cut = NA, sp.check = TRUE,
                       phylo.rand.scale = "within.bin", taxa.rand.scale = "across.all",
                       phylo.metric = "bMPD", sig.index=sig.index, bin.size.limit = bin.size.limit, 
                       nworker = nworker, memory.G = memory.G, rtree.save = FALSE, detail.save = TRUE, 
                       qp.save = FALSE, detail.null = FALSE, ignore.zero = TRUE, output.wd = save.wd, 
                       correct.special = TRUE, unit.sum = rowSums(comm), special.method = "depend",
                       ses.cut = 1.96, rc.cut = 0.95, conf.cut=0.975, omit.option = "no",meta.ab = NULL)
# there are quite a few parameters in this function, please check the help document of "icamp.big".
# output files:
# Test.iCAMP.detail.rda: the object "icres" saved in R data format. it is a list object. 
# The first element bNRIiRCa is the result of relative importance of each assembly process in each pairwise comparison (each turnover). 
# The second element "detail" including binning information (named taxabin), phylogenetic and taxonomic metrics results in each bin (named like bNRIi, RCa, etc.), 
# relative abundance of each bin (bin.weight), relative importance of each process in each turnover between communities (processes), input settings (setting), and input community data matrix (comm). 
# See help document of the function icamp.big for more details.

head(icres$CbMPDiCBraya)

### 4-3. community data transformation and taxonomic dissimilarity index change ####
comra=comm/rowSums(comm)
taxo.metric='bray'
transform.method='hellinger'
prefixtran=paste0(prefix,"hell")
omit.option = "no"
bin.size.limit = 5 # default value is 24.
icres <- iCAMP::icamp.big(comm=comm,tree=tree,pd.desc=pd.big$pd.file, pd.spname=pd.big$tip.label, pd.wd=pd.big$pd.wd,
                        rand=rand.time,prefix=prefixtran,ds=0.2,pd.cut=NA,sp.check=TRUE,
                        phylo.rand.scale="within.bin",taxa.rand.scale="across.all",
                        phylo.metric="bMPD",sig.index="Confidence",
                        bin.size.limit=bin.size.limit,nworker=nworker,memory.G=memory.G,
                        rtree.save=FALSE,detail.save=TRUE,qp.save=FALSE,detail.null=FALSE,
                        ignore.zero=TRUE,output.wd=save.wd,correct.special=TRUE,unit.sum=rowSums(comra),
                        special.method="depend",ses.cut = 1.96,rc.cut = 0.95,conf.cut=0.975,
                        omit.option="no",meta.ab=NULL, taxo.metric=taxo.metric, transform.method=transform.method,
                        logbase=2, dirichlet=FALSE)

head(icres$CbMPDiCBraya)

## 5. iCAMP bin level statistics ####
icbin <- icamp.bins(icamp.detail = icres$detail,treat = treat,
                        clas=clas,silent=FALSE, boot = TRUE,
                        rand.time = rand.time,between.group = TRUE)
### save results as text tables to the designated directory
save(icbin,file = paste0(prefix,".iCAMP.Summary.rda")) # just to archive the result. rda file is automatically compressed, and easy to load into R.
write.csv(icbin$Pt,file = paste0(prefix,".ProcessImportance_EachGroup.csv"),row.names = FALSE)
write.csv(icbin$Ptk,file = paste0(prefix,".ProcessImportance_EachBin_EachGroup.csv"),row.names = FALSE)
write.csv(icbin$Ptuv,file = paste0(prefix,".ProcessImportance_EachTurnover.csv"),row.names = FALSE)
write.csv(icbin$BPtk,file = paste0(prefix,".BinContributeToProcess_EachGroup.csv"),row.names = FALSE)
write.csv(data.frame(ID=rownames(icbin$Class.Bin),icbin$Class.Bin,stringsAsFactors = FALSE),
          file = paste0(prefix,".Taxon_Bin.csv"),row.names = FALSE)
write.csv(icbin$Bin.TopClass,file = paste0(prefix,".Bin_TopTaxon.csv"),row.names = FALSE)

# output files:
# Test.iCAMP.Summary.rda: the object "icbin" saved in R data format. see help document of the function icamp.bins for description of each element in the object.
# Test.ProcessImportance_EachGroup.csv: Relative importance of each process in governing the turnovers in a group of samples.
# Test.ProcessImportance_EachBin_EachGroup.csv: Relative importance of each process in governing the turnovers of each bin among a group of samples.
# Test.ProcessImportance_EachTurnover.csv: Relative importance of each process in governing the turnovers between each pair of communities (samples).
# Test.BinContributeToProcess_EachGroup.csv: Bin contribution to each process, measuring the contribution of each bin to the relative importance of each process in the assembly of a group of communities.
# Test.Taxon_Bin.csv: a matrix showing the bin ID and classification information for each taxon.
# Test.Bin_TopTaxon.csv: a matrix showing the bin relative abundance; the top taxon ID, percentage in bin, and classification; the most abundant name at each phylogeny level in the bin.

## 6. Visualization ####
### 6-1. Community level ####
#### 6-1-1. parse data from the result ####
bac.icamp <- icres$CbMPDiCBraya
bac.icamp.num<-bac.icamp[-c(1,2)] # remove the first and second column
head(bac.icamp.num) # show data in the first six rows
bac.icamp.summary<-colMeans(bac.icamp.num) # calculate the mean values of each driver
df.bac.icamp.summary <- data.frame(bac.icamp.summary) # covert to a data frame object
names(df.bac.icamp.summary)[1] <- "RelativeImportance" # change the column name
df.bac.icamp.summary

#### 6-1-2. format the data to fit to ggplot2 ####
df.bac.icamp.summary$Mechanism <- rownames(df.bac.icamp.summary) # create the column Mechanism (or driver)
df.bac.rel.imp.tab.melt <- reshape2::melt(df.bac.icamp.summary)
colnames(df.bac.rel.imp.tab.melt)
names(df.bac.rel.imp.tab.melt)[3] <- "RelImportance"
df.bac.rel.imp.tab.melt$Kingdom <- "Bacteria"
### arrange the values of the column "Mechanism"
df.bac.rel.imp.tab.melt$Mechanism <- factor(df.bac.rel.imp.tab.melt$Mechanism, levels = rev(c("Homogeneous.Selection","Heterogeneous.Selection",
                                                                                              "Dispersal.Limitation", "Homogenizing.Dispersal",
                                                                                              "Drift.and.Others")))
head(df.bac.rel.imp.tab.melt)

#### 6-1-3. plotting ####
ggplot(df.bac.rel.imp.tab.melt, aes(x=Kingdom, y = RelImportance, fill = Mechanism)) + 
  geom_bar(stat="identity", width = 0.8, position = 'stack') +
  scale_fill_manual(values = c("Homogeneous.Selection"= "#3c93c2","Heterogeneous.Selection" = "#9ec9e2",
                               "Dispersal.Limitation" = "#fcde9c", "Homogenizing.Dispersal" = "#feb24c",
                               "Drift.and.Others"="#fc4e2a")) +
  
  xlab('')+ theme(aspect.ratio = 2) + 
  ylab("Relative importance \n") +
  guides(fill = guide_legend(nrow = 5,reverse = F))+
  theme(legend.position="right") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 13,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, vjust=0.4,size=12, face='bold',color='black'))+
  theme(axis.text.y = element_text(size=15, face='bold',color='black'))+
  scale_y_continuous(breaks=seq(0,1,0.2))+
  theme(panel.grid.major = element_blank()) +
  theme(panel.grid.minor = element_blank(), panel.background=element_blank(),panel.border=element_blank(), plot.background=element_blank())

### 6-2. Phylogenetic bin level ####
#### 6-2-1. parse data from the result ####
bac.phylo.bin<-read.csv("Test.ProcessImportance_EachBin_EachGroup.csv")
head(bac.phylo.bin)
bac.phylo.bin <- bac.phylo.bin[-c(1,2)] # remove the first and second column
bac.phylo.bin <- subset(bac.phylo.bin, !(rownames(bac.phylo.bin) %in% rownames(bac.phylo.bin[grep("DominantProcess",bac.phylo.bin$Index),]))) # remove rows containing the value DominantProcess in the column Index

### change the class to numeric if the class of relative importance values is character
i<-c(3:ncol(bac.phylo.bin))
bac.phylo.bin[, i] <- apply(bac.phylo.bin[ , i], 2,function(x) as.numeric(as.character(x)))
head(bac.phylo.bin)
#### 6-2-2. format the data to fit to ggplot2 ####
bac.phylo.bin.melt <- reshape2::melt(bac.phylo.bin)
subset(bac.phylo.bin.melt, value == "NaN") ### check if there is "NaN" among values
bac.phylo.bin.melt<-subset(bac.phylo.bin.melt, value != "NaN") ### remove "NaN" when it exists
bac.phylo.bin.melt.mean <- bac.phylo.bin.melt %>% group_by(Index, variable) %>% summarise(MeanRelImportance = mean(value))
names(bac.phylo.bin.melt.mean)[2] <- "Bin"
head(bac.phylo.bin.melt.mean)

### arrange values
bac.phylo.bin.melt.mean$Bin <- factor(bac.phylo.bin.melt.mean$Bin, levels = c("bin1","bin2","bin3","bin4","bin5"))
bac.phylo.bin.melt.mean$Index <- factor(bac.phylo.bin.melt.mean$Index, levels = rev(c("HoS","HeS","DL","HD","DR")))

#### 6-2-3. plotting ####
ggplot(bac.phylo.bin.melt.mean, aes(x=Bin, y = MeanRelImportance, fill = Index)) + 
  geom_bar(stat="identity", width = 0.8, position = 'stack') +
  #scale_fill_discrete() +
  scale_fill_manual(values = c("HoS"= "#3c93c2","HeS" = "#9ec9e2",
                               "DL" = "#fcde9c", "HD" = "#feb24c",
                               "DR"="#fc4e2a")) +
  
  xlab('')+ theme(aspect.ratio = 1) + 
  ylab("Relative importance \n") +
  #ggtitle("Phylum Community Composition by Sample \n") +
  ## adjust positions
  guides(fill = guide_legend(nrow = 5,reverse = F))+
  theme(legend.position="right") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 13,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust=0.4,size=12, face='bold',color='black'))+
  theme(axis.text.y = element_text(size=15, face='bold',color='black'))+
  scale_y_continuous(breaks=seq(0,1,0.2))+
  theme(panel.grid.major = element_blank()) +
  theme(panel.grid.minor = element_blank(), panel.background=element_blank(),panel.border=element_blank(), plot.background=element_blank())
